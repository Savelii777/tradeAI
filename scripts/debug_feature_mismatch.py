#!/usr/bin/env python3
"""Debug feature mismatch between backtest and live."""
import sys
sys.path.insert(0, 'scripts')
import pandas as pd
import numpy as np
import joblib
import ccxt
from train_mtf import MTFFeatureEngine
import warnings
warnings.filterwarnings('ignore')

# Load models
print('Loading models...')
direction_model = joblib.load('models/v1_fresh/direction_model.joblib')
timing_model = joblib.load('models/v1_fresh/timing_model.joblib')
feature_names = list(direction_model.feature_name_)
print(f'Model expects {len(feature_names)} features')
print(f'First 20 expected features: {feature_names[:20]}')

# Initialize exchange
exchange = ccxt.binance({'enableRateLimit': True, 'options': {'defaultType': 'future'}})
mtf_engine = MTFFeatureEngine()

# Fetch OHLCV
pair = 'BTC/USDT'
print(f'\nFetching {pair} data...')
df_1m = exchange.fetch_ohlcv(pair, '1m', limit=200)
df_5m = exchange.fetch_ohlcv(pair, '5m', limit=200)
df_15m = exchange.fetch_ohlcv(pair, '15m', limit=200)

df_1m = pd.DataFrame(df_1m, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
df_5m = pd.DataFrame(df_5m, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
df_15m = pd.DataFrame(df_15m, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

df_1m['timestamp'] = pd.to_datetime(df_1m['timestamp'], unit='ms')
df_5m['timestamp'] = pd.to_datetime(df_5m['timestamp'], unit='ms')
df_15m['timestamp'] = pd.to_datetime(df_15m['timestamp'], unit='ms')

df_1m.set_index('timestamp', inplace=True)
df_5m.set_index('timestamp', inplace=True)
df_15m.set_index('timestamp', inplace=True)

print(f'Data: 1m={len(df_1m)}, 5m={len(df_5m)}, 15m={len(df_15m)}')

# Test 1: align_timeframes (backtest method)
print('\n' + '='*60)
print('TEST 1: align_timeframes (backtest method)')
print('='*60)
features_bt = mtf_engine.align_timeframes(df_1m, df_5m, df_15m)
print(f'Rows: {len(features_bt)}')
print(f'Columns: {len(features_bt.columns)}')
if len(features_bt) > 0:
    print(f'First 20 columns: {list(features_bt.columns[:20])}')

# Test 2: generate_live_features (paper_trading method)
print('\n' + '='*60)
print('TEST 2: generate_live_features (paper_trading method)')
print('='*60)

def generate_live_features(mtf_engine, df_1m, df_5m, df_15m):
    m15_features = mtf_engine.generate_m15_trend_features(df_15m)
    m5_features = mtf_engine.generate_m5_signal_features(df_5m)
    m1_features = mtf_engine.generate_m1_timing_features(df_1m)
    
    if m5_features.empty or m15_features.empty or m1_features.empty:
        return pd.DataFrame()
    
    result = m5_features.iloc[[-1]].copy()
    
    m15_last = m15_features.iloc[-1]
    for col in m15_features.columns:
        result[col] = m15_last[col]
    
    m1_last_5 = m1_features.iloc[-5:] if len(m1_features) >= 5 else m1_features
    
    for col in m1_features.columns:
        if 'momentum' in col or 'rsi' in col:
            result[f'{col}_last'] = m1_last_5[col].iloc[-1]
            result[f'{col}_mean'] = m1_last_5[col].mean()
            result[f'{col}_std'] = m1_last_5[col].std()
        else:
            result[f'{col}_last'] = m1_last_5[col].iloc[-1]
    
    result = result.fillna(0)
    
    for col in result.columns:
        if result[col].dtype == 'object':
            result[col] = pd.Categorical(result[col]).codes
    
    return result

features_live = generate_live_features(mtf_engine, df_1m, df_5m, df_15m)
print(f'Rows: {len(features_live)}')
print(f'Columns: {len(features_live.columns)}')
print(f'First 20 columns: {list(features_live.columns[:20])}')

# Compare features
print('\n' + '='*60)
print('FEATURE COMPARISON')
print('='*60)

live_cols = set(features_live.columns)
expected_cols = set(feature_names)

missing_in_live = expected_cols - live_cols
extra_in_live = live_cols - expected_cols

print(f'Expected by model: {len(expected_cols)}')
print(f'Generated by live: {len(live_cols)}')
print(f'Missing in live (need to add 0): {len(missing_in_live)}')
print(f'Extra in live (not used by model): {len(extra_in_live)}')

if missing_in_live:
    print(f'\nFirst 20 missing: {list(missing_in_live)[:20]}')

# Now try to get prediction with live features
print('\n' + '='*60)
print('TESTING PREDICTION WITH LIVE FEATURES')
print('='*60)

# Add missing features
for feat in feature_names:
    if feat not in features_live.columns:
        features_live[feat] = 0

X = features_live[feature_names]
print(f'X shape: {X.shape}')

try:
    dir_proba = direction_model.predict_proba(X)[0]
    timing_proba = timing_model.predict_proba(X)[0]
    
    direction_idx = np.argmax(dir_proba)
    direction_map = {0: 'SHORT', 1: 'HOLD', 2: 'LONG'}
    
    print(f'\nPredictions:')
    print(f'  Direction: {direction_map[direction_idx]}')
    print(f'  Direction probs: DOWN={dir_proba[0]:.3f}, HOLD={dir_proba[1]:.3f}, UP={dir_proba[2]:.3f}')
    print(f'  Timing proba: {timing_proba[1]:.4f}')
    
    # Check if signal would be generated
    is_good_timing = timing_proba[1] > 0.01
    max_prob = max(dir_proba)
    
    print(f'\nWould generate signal?')
    print(f'  timing > 0.01: {is_good_timing} ({timing_proba[1]:.4f})')
    print(f'  max_prob >= 0.50: {max_prob >= 0.50} ({max_prob:.3f})')
    print(f'  direction != HOLD: {direction_idx != 1}')
    
    signal = 0
    if is_good_timing and max_prob >= 0.50 and direction_idx != 1:
        signal = 1 if direction_idx == 2 else -1
    
    print(f'  SIGNAL: {signal}')
    
except Exception as e:
    print(f'Error: {e}')
    import traceback
    traceback.print_exc()
